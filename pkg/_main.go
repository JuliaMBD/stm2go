package stm2go

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

const (
	debugLog  = false
	debugTest = false
)

// mapを作成して，id(3や1などの数字)とラベルを対応させる？
// 接頭語をつけた hogeState みたいな？型名を定義　接頭語のほうがいい
// {{.hoge}}State で波括弧内を置き換える
// ステートマシンごとにファイルを分ける，同じパッケージ内にはある．

// ヒアドキュメントでソースコードは記載．appendはちょっと…．変数が使えない場合は
// text/templateパッケージを使うと簡単に書けるかも

// [1, 2, 3, ...] = ["top", "child", ...]

func remove(transition_list []*Transition, state_name *State) []*Transition {
	ret := make([]*Transition, len(transition_list))
	i := 0

	for _, transition := range transition_list {
		if state_name != transition.Src {
			ret[i] = transition
			i++
		}
	}

	return ret[:i]
}

// ------------------------------　hogehoge_base.go　-----------------------------------

func writePackage(oline []string, name string, count int) []string {
	oline = append(oline, fmt.Sprintf("package %s\n", name))

	if count == 0 {
		oline = append(oline, `
		// Please do not edit this file.

		import (
		// package name to import
		)

		const (
			debug = true
		)
		`)
	} else {
		oline = append(oline, `
			// Please do not edit this file.

			import (
			// package name to import
			)
			`)
	}

	return oline
}

// enum宣言
func writeEnum(oline []string, state_list []*State, m map[string]string, key string, count int) []string {
	oline = append(oline, fmt.Sprintf("type %sState int\n", strings.Title(m[key])))
	oline = append(oline, "const (\n")
	for index, state := range state_list {
		if index == 0 {
			oline = append(oline, fmt.Sprintf("%s %sState = iota\n", state.Name, strings.Title(m[key])))
			continue
		}
		oline = append(oline, fmt.Sprintf("%s\n", state.Name))
	}
	oline = append(oline, ")\n")
	oline = append(oline, "\n")

	if count == 0 {
		oline = append(oline, `
		type Eod int

		const (
			Entry Eod = iota
			Do
			Exit
		)
	`)
	}

	oline = append(oline, fmt.Sprintf("var %seod Eod\n", m[key]))
	oline = append(oline, fmt.Sprintf("var %sCurrentState %sState\n", m[key], strings.Title(m[key])))
	oline = append(oline, "\n")

	return oline
}

// task関数の生成
func writeEvent(oline []string, transition_list []*Transition, m map[string]string, key string) []string {
	// 状態ごとの関数を作成
	oline = append(oline, fmt.Sprintf("func %sStep() {\n", strings.Title(m[key])))
	oline = append(oline, fmt.Sprintf("switch %sCurrentState {\n", m[key]))

	for _, transition := range transition_list {
		state_name := transition.Src
		if state_name == transition.Src {
			oline = append(oline, fmt.Sprintf("case %s:\n", transition.Src.Name))
			// Entry状態での動作を記述
			oline = append(oline, fmt.Sprintf("if %seod == Entry {\n", m[key]))
			oline = append(oline, fmt.Sprintf("%sEntry()\n", strings.ToLower(transition.Src.Name)))
			oline = append(oline, fmt.Sprintf("%seod = Do\n", m[key]))
			oline = append(oline, "}\n") // if eod == Entry

			// Do状態での動作を記述
			oline = append(oline, fmt.Sprintf("if %seod == Do {\n", m[key]))
			oline = append(oline, fmt.Sprintf("%sDo()\n", strings.ToLower(transition.Src.Name)))
			// 遷移条件を列挙
			for _, transition := range transition_list {
				if state_name == transition.Src {
					oline = append(oline, fmt.Sprintf("if %sCond() {\n", transition.Event.Name))
					oline = append(oline, fmt.Sprintf("%sCurrentState = %s\n", m[key], transition.Dest.Name))
					oline = append(oline, fmt.Sprintf("if debug {\n"))
					oline = append(oline, fmt.Sprintf("logger.Println(\"State is changed: %s to %s\")\n", transition.Src.Name, transition.Dest.Name))
					oline = append(oline, fmt.Sprintf("}\n"))
					oline = append(oline, fmt.Sprintf("%seod = Exit\n", m[key]))
					oline = append(oline, "}\n") // if event_Cond()
				}
			}

			oline = append(oline, "}\n") // if eod == Do

			// Exit状態での動作を記述
			oline = append(oline, fmt.Sprintf("if %seod == Exit {\n", m[key]))
			oline = append(oline, fmt.Sprintf("%sExit()\n", strings.ToLower(transition.Src.Name)))
			oline = append(oline, fmt.Sprintf("%seod = Entry\n", m[key]))
			oline = append(oline, "}\n") // if eod == Exit

			transition_list = remove(transition_list, state_name) // 表示したtransitionをリストから削除
			if len(transition_list) == 0 {
				break
			}
		}
	}
	oline = append(oline, "}\n") // switch state
	oline = append(oline, "}\n") // func
	oline = append(oline, "\n")

	return oline
}

// ステートの初期化
func writeInit(oline []string, initial *State, m map[string]string, key string) []string {
	oline = append(oline, "func init() {\n")
	oline = append(oline, fmt.Sprintf("%sCurrentState = %s\n", m[key], initial.Name))
	oline = append(oline, fmt.Sprintf("%seod = Entry\n", m[key]))
	oline = append(oline, "}\n")
	oline = append(oline, "\n")

	return oline
}

// ------------------------------　hogehoge_impl.go　-----------------------------------

// パッケージ名，インポート
func writePackageEdit(oeline []string, name string, count int) []string {
	oeline = append(oeline, fmt.Sprintf("package %s\n", name))

	if count == 0 {
		oeline = append(oeline, `

	// Please edit this file

	import (
		// package name to import
	)

	type DebugLogger interface {
		Println(string)
	}

	var logger DebugLogger

	func ConfigureLog(p DebugLogger) {
		logger = p
	}
	`)
	} else {
		oeline = append(oeline, `

	// Please edit this file

	import (
		// package name to import
	)
	`)
	}

	return oeline

}

// modelBase.goにて使用する関数を表記
func writeFunc(oeline []string, state_list []*State, event_list []*Event) []string {
	for _, state := range state_list {
		oeline = append(oeline, fmt.Sprintf("func %sEntry() {\n", strings.ToLower(state.Name)))
		oeline = append(oeline, "// nothing to do\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")

		oeline = append(oeline, fmt.Sprintf("func %sDo() {\n", strings.ToLower(state.Name)))
		oeline = append(oeline, "// nothing to do\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")

		oeline = append(oeline, fmt.Sprintf("func %sExit() {\n", strings.ToLower(state.Name)))
		oeline = append(oeline, "// nothing to do\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")
	}

	for _, event := range event_list {
		oeline = append(oeline, fmt.Sprintf("func %sCond() bool {\n", event.Name))
		oeline = append(oeline, "// Please write the conditions under which a state transitions\n")
		oeline = append(oeline, "return true\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")
	}

	return oeline
}

// ------------------------------　hogehoge_test.go　-----------------------------------
// テストファイルを生成
func writeTest(otline []string, name string, m map[string]string, key string, count int) []string {
	otline = append(otline, fmt.Sprintf("package %s\n", name))

	otline = append(otline, `

// This is a test file for testing state transitions

import (
	"log"
	"testing"
	"time"
)
`)

	if count == 0 {
		otline = append(otline, `
type DebugStruct struct{}

var logTest = DebugStruct{}

func (l DebugStruct) Println(debstr string) {
	log.Println(debstr)
}
`)
	}

	otline = append(otline, fmt.Sprintf("func %sTestDevice(t *testing.T) {", strings.Title(m[key])))
	otline = append(otline, `
	env := sm2go.NewTestEnv() // TestEnv構造体

	// goroutine(base.go Task())
	env.Add(sm2go.Continue, func() {
		for {
			time.Sleep(10 * time.Millisecond)
`)

	otline = append(otline, fmt.Sprintf("%sStep()\n", strings.Title(m[key])))

	otline = append(otline, `
		}
	},
	)

	// goroutine(user operation)
	env.Add(sm2go.Done, func() {
	},
	)

	env.Set(1)
	env.Go()
}
`)

	return otline
}

// ------------------------------　sm2go.go　-----------------------------------
//　ライブラリを生成
func writeSm(osline []string) []string {
	osline = append(osline, `
package sm2go

import (
	"sync"
	"time"
)

type Tasktype int

const (
	Done Tasktype = iota
	Continue
)

type TestEnv struct {
	task      []func()
	wg        *sync.WaitGroup
	timescale time.Duration
}

func NewTestEnv() *TestEnv {
	return &TestEnv{
		task:      []func(){},
		wg:        &sync.WaitGroup{},
		timescale: 1,
	}
}

func (t *TestEnv) Add(tasktype Tasktype, x func()) {
	switch tasktype {
	case Done:
		t.wg.Add(1)
		t.task = append(t.task, func() {
			defer t.wg.Done()
			x()
		})
	case Continue:
		t.task = append(t.task, x)
	}
}

func (t *TestEnv) Set(i time.Duration) {
	t.timescale = i
}

func (t *TestEnv) Go() {
	for _, x := range t.task {
		go x()
	}
	t.wg.Wait()
}

func (t *TestEnv) Sleep(h time.Duration) {
	time.Sleep(h * t.timescale)
}

func (t *TestEnv) Tick(i time.Duration) <-chan time.Time {
	return time.Tick(i * t.timescale)
}

func (t *TestEnv) After(i time.Duration) <-chan time.Time {
	return time.After(i * t.timescale)
}
`)

	return osline
}

// ------------------------------　main.go　-----------------------------------
func writeMain(omline []string) []string {
	omline = append(omline, `
// main file

package main

import (
	"time"
)

type DebugStruct struct{}

var logTest = DebugStruct{}

func (l DebugStruct) Println(debstr string) {
	println(debstr)
}

func main() {
	for {
		Task()
		time.sleep(time.Millisecond * 10)
	}
}
`)

	return omline
}

// main.goにて実行する関数
func WriteAll(data []byte, name string, key string, v *StateMachine, m map[string]string, count int) ([]string, []string, []string, []string, []string) {
	var oline []string
	var oeline []string
	var otline []string
	var osline []string
	var omline []string

	// ------------------------------　model_base.go　-----------------------------------
	oline = writePackage(oline, name, count)
	oline = writeEnum(oline, v.States, m, key, count)
	oline = writeEvent(oline, v.Transitions, m, key)
	oline = writeInit(oline, v.Initial, m, key)
	// ------------------------------　model_impl.go　-----------------------------------
	oeline = writePackageEdit(oeline, name, count)
	oeline = writeFunc(oeline, v.States, v.Events)
	// ------------------------------　model_test.go　-----------------------------------
	otline = writeTest(otline, name, m, key, count)
	// ------------------------------　sm2go.go　-----------------------------------
	osline = writeSm(osline)
	// ------------------------------　main.go　-----------------------------------
	omline = writeMain(omline)

	return oline, oeline, otline, omline, osline
}

func main() {
	infile := flag.String("i", "", "diagrams.net file for State Machine")
	flag.Parse()

	count := 0

	m := map[string]string{"1": "one", "2": "two", "3": "three"}

	var oline []string
	var oeline []string
	var otline []string
	var omline []string
	var osline []string

	// ディレクトリ生成
	if err := os.MkdirAll(fmt.Sprintf("%s", os.Args[3]), 0777); err != nil {
		panic(err)
	}

	if *infile != "" {
		if xml, err := ioutil.ReadFile(*infile); err == nil {
			result := sm2go.Parse(xml)

			for key, v := range result {
				base, err := os.Create(fmt.Sprintf("%s/%s_base.go", os.Args[3], os.Args[3]))
				if err != nil {
					fmt.Println(err)
					return
				}
				defer base.Close()

				impl, err := os.Create(fmt.Sprintf("%s/%s_impl.go", os.Args[3], os.Args[3]))
				if err != nil {
					fmt.Println(err)
					return
				}
				defer impl.Close()

				test, err := os.Create(fmt.Sprintf("%s/%s_test.go", os.Args[3], os.Args[3]))
				if err != nil {
					fmt.Println(err)
					return
				}
				defer test.Close()

				oline, oeline, otline, omline, osline = sm2go.WriteAll(xml, os.Args[3], key, v, m, count)

				// package_base.go
				for _, o := range oline {
					b := []byte(o)
					_, err := base.Write(b)
					if err != nil {
						panic(err)
					}
				}

				// package_impl.go
				for _, oe := range oeline {
					b := []byte(oe)
					_, err := impl.Write(b)
					if err != nil {
						panic(err)
					}
				}

				// package_test.go
				for _, ot := range otline {
					b := []byte(ot)
					_, err := test.Write(b)
					if err != nil {
						panic(err)
					}
				}

				count++
			}

		} else {
			panic(err)
		}
	}

	// sm2goディレクトリ生成
	if err := os.Mkdir("sm2go", 0777); err != nil {
		fmt.Println(err)
	}

	// sm2go.go生成
	sm, err := os.Create("sm2go/sm2go.go")
	if err != nil {
		panic(err)
	}
	defer sm.Close()

	// main.go生成
	main, err := os.Create("main.go")
	if err != nil {
		panic(err)
	}
	defer main.Close()

	// sm2go.go
	for _, os := range osline {
		b := []byte(os)
		_, err := sm.Write(b)
		if err != nil {
			panic(err)
		}
	}

	// main.go
	for _, om := range omline {
		b := []byte(om)
		_, err := main.Write(b)
		if err != nil {
			panic(err)
		}
	}
}

// // 入力ファイル（diagrams.netにて作成）の読み込み
// if *infile != "" {
// 	if xml, err := ioutil.ReadFile(*infile); err == nil {
// 		oline, oeline, otline, omline, osline = sm2go.WriteAll(xml, os.Args[3])
// 	} else {
// 		panic(err)
// 	}
// }

// // ディレクトリ生成
// if err := os.MkdirAll(fmt.Sprintf("%s", os.Args[3]), 0777); err != nil {
// 	panic(err)
// }

// // package_base.go生成
// base, err := os.Create(fmt.Sprintf("%s/%s_base.go", os.Args[3], os.Args[3]))
// if err != nil {
// 	panic(err)
// }
// defer base.Close()

// // package_impl.go生成
// impl, err := os.Create(fmt.Sprintf("%s/%s_impl.go", os.Args[3], os.Args[3]))
// if err != nil {
// 	panic(err)
// }
// defer impl.Close()

// // package_test.go生成
// test, err := os.Create(fmt.Sprintf("%s/%s_test.go", os.Args[3], os.Args[3]))
// if err != nil {
// 	panic(err)
// }
// defer test.Close()

// // sm2go.go生成
// if err := os.Mkdir("sm2go", 0777); err != nil {
// 	fmt.Println(err)
// }

// sm, err := os.Create("sm2go/sm2go.go")
// if err != nil {
// 	panic(err)
// }
// defer sm.Close()

// // main.go生成
// main, err := os.Create("main.go")
// if err != nil {
// 	panic(err)
// }
// defer main.Close()

// // package_base.go
// for _, o := range oline {
// 	b := []byte(o)
// 	_, err := base.Write(b)
// 	if err != nil {
// 		panic(err)
// 	}
// }

// // package_impl.go
// for _, oe := range oeline {
// 	b := []byte(oe)
// 	_, err := impl.Write(b)
// 	if err != nil {
// 		panic(err)
// 	}
// }

// // package_test.go
// for _, ot := range otline {
// 	b := []byte(ot)
// 	_, err := test.Write(b)
// 	if err != nil {
// 		panic(err)
// 	}
// }

// // sm2go.go
// for _, os := range osline {
// 	b := []byte(os)
// 	_, err := sm.Write(b)
// 	if err != nil {
// 		panic(err)
// 	}
// }

// // main.go
// for _, om := range omline {
// 	b := []byte(om)
// 	_, err := main.Write(b)
// 	if err != nil {
// 		panic(err)
// 	}
// }
