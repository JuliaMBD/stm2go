package stm2go

import (
	"io"
)

type GoSource struct {
	pkgname string
	out     io.Writer
}

func (g *GoSource) writeln(s string) {
	g.out.Write([]byte(s + "\n"))
}

func NewGoSource(out io.Writer, s string) *GoSource {
	return &GoSource{
		pkgname: s,
		out:     out,
	}
}

// A function to generate the string of header
func (g *GoSource) baseHeader() {
	g.writeln("// This file was generated by a program.")
	g.writeln("// Please do not edit this file directly.")
	g.writeln("package " + g.pkgname + "\n")
	g.writeln("import (\n// package names to be imported\n)\n")
}

// A function to generate Enum for states
func (g *GoSource) baseStateDefinition(stm string, ss []*State) {
	g.writeln("type " + stm + "State int")
	g.writeln("const (")
	for i, s := range ss {
		if i == 0 {
			g.writeln(s.Name + " " + stm + "State = iota")
		} else {
			g.writeln(s.Name)
		}
	}
	g.writeln(")\n")
}

// A function to generate init function
func (g *GoSource) baseStateInitialize(stm string, i *State) {
	g.writeln("func init() {")
	g.writeln(stm + "CurrentState = " + i.Name)
	g.writeln("}\n")
}

//
func (g *GoSource) baseTransDefinition(stm string, ss []*State, ts map[*State][]*Transition) {
	g.writeln("func " + stm + "Task() {")
	g.writeln("switch " + stm + "CurrentState {")
	for _, s := range ss {
		g.writeln("case " + s.Name + ":")
		g.writeln("if " + stm + "Eod == Entry {")
		g.writeln(s.Name + "Entry()")
		g.writeln(stm + "Eod = Do")
		g.writeln("}")
		g.writeln("if " + stm + "Eod == Do {")
		g.writeln(s.Name + "Do()")
		for _, t := range ts[s] {
			g.writeln("if " + t.Event.Name + "Cond() {")
			g.writeln(stm + "CurrentState = " + t.Dest.Name)
			g.writeln(stm + "Eod = Exit")
			g.writeln("}")
		}
		g.writeln("}")
		g.writeln("if " + stm + "Eod == Exit {")
		g.writeln(s.Name + "Exit()")
		g.writeln(stm + "Eod = Entry")
		g.writeln("}")
	}
	g.writeln("}")
	g.writeln("}\n")
}

// A function to generate the string of header for impl
func (g *GoSource) implHeader() {
	g.writeln("// This file was generated by a program.")
	g.writeln("package " + g.pkgname)
	g.writeln("import (\n// package names to be imported\n)")
}

// A function to generate common
func (g *GoSource) common() {
	g.writeln("// This file was generated by a program.")
	g.writeln("package " + g.pkgname + "\n")
	g.writeln("import (\n// package names to be imported\n)\n")
	g.writeln("type DebugLogger interface {\nPrintln(string)\n}\n")
	g.writeln("var logger DebugLogger\n")
	g.writeln("func ConfigureLog(p DebugLogger) {\nlogger = p\n}\n")
	g.writeln("const (\ndebug = true\n)\n")
}

// A function to generate template functions
func (g *GoSource) implFunctions(ss []*State, ts map[*State][]*Transition) {
	for _, s := range ss {
		g.writeln("// functions for State " + s.Name + "\n")
		g.writeln("func " + s.Name + "Entry() {")
		g.writeln("if debug {")
		g.writeln("logger.Println(\"Entering State " + s.Name + "\")")
		g.writeln("}")
		g.writeln("// Please write an enter process for State " + s.Name)
		g.writeln("}\n")
		g.writeln("func " + s.Name + "Do() {")
		g.writeln("// Please write a do process for State " + s.Name)
		g.writeln("}\n")
		g.writeln("func " + s.Name + "Exit() {")
		g.writeln("if debug {")
		g.writeln("logger.Println(\"Leaving State " + s.Name + "\")")
		g.writeln("}")
		g.writeln("// Please write an exit process for State " + s.Name)
		g.writeln("}\n")
		for _, t := range ts[s] {
			g.writeln("func " + t.Event.Name + "Cond() bool {")
			g.writeln("// Please edit the condition")
			g.writeln("return true")
			g.writeln("}\n")
		}
	}
}

// A function to generate an example of test code
func (g *GoSource) testGen(stmname string) {
	g.writeln("// This file was generated by a program.")
	g.writeln("package " + g.pkgname + "\n")
	g.writeln("import (\n\"log\"\n\"testing\"\n\"time\"\n\"com.github/JuliaMBD/stm2go\"\n)\n")
	g.writeln("type DebugStruct struct{}\n")
	g.writeln("func (l DebugStruct) Println(s string) {")
	g.writeln("log.Println(s)")
	g.writeln("}\n")
	g.writeln("var logTest = DebugStruct{}\n")
	g.writeln("func " + g.pkgname + "TestExample(t *testing.T) {")
	g.writeln("env := stm2go.NewTestEnv()\n")
	g.writeln("env.Add(stm2go.Continue, func() {")
	g.writeln("for {")
	g.writeln("time.Sleep(10 * time.Millisecond)")
	g.writeln(stmname + "Task()")
	g.writeln("}")
	g.writeln("})")
	g.writeln("env.Add(stm2go.Done, func() {")
	g.writeln("})")
	g.writeln("env.Set(1)")
	g.writeln("env.Go()")
	g.writeln("}")
}
