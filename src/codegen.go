package stm2go

import (
	"io"
)

const srcdir string = "src"

type GoPkgSource struct {
	fullpkgname string
	pkgname     string
}

type GoSTMSource struct {
	name    string
	ss      []*State
	ts      map[*State][]*Transition
	initial *State
	pkg     *GoPkgSource
}

// A function to create GoSource
//   out: io.Writer (e.g. os.Stdout)
//   domain: domain name for package
//   pkgname: package name
func NewGoPkgSource(domain string, pkgname string) *GoPkgSource {
	return &GoPkgSource{
		fullpkgname: domain + "/" + pkgname,
		pkgname:     pkgname,
	}
}

// A function to create GoSTMSource
//   out: io.Writer
//   name: name of STM
//   ss: Slice of States
//   ts: Slice of Transitions
//   initial: Initial State
//   pkg: GoSource for Pkg
func NewGoSTMSource(name string,
	ss []*State, ts []*Transition, initial *State, pkg *GoPkgSource) *GoSTMSource {
	return &GoSTMSource{
		name:    name,
		ss:      ss,
		ts:      makeTransitionMap(ts),
		initial: initial,
		pkg:     pkg,
	}
}

// A function to make map between a parent state and a state machine
func NewGoSTMMap(pkg *GoPkgSource, names map[string]string,
	stms map[string]*StateMachine, states map[string]*State) ([]*GoSTMSource, map[*State][]*GoSTMSource, *State) {
	stmap := make([]*GoSTMSource, 0)
	sttree := make(map[*State][]*GoSTMSource)
	root := &State{Name: "root"}
	for k, s := range stms {
		st := NewGoSTMSource(names[k], s.States, s.Transitions, s.Initial, pkg)
		stmap = append(stmap, st)
		if p, ok := states[s.Parent]; ok {
			if _, ok := sttree[p]; ok {
				sttree[p] = append(sttree[p], st)
			} else {
				sttree[p] = []*GoSTMSource{st}
			}
		} else {
			if _, ok := sttree[root]; ok {
				sttree[root] = append(sttree[root], st)
			} else {
				sttree[root] = []*GoSTMSource{st}
			}
		}
	}
	return stmap, sttree, root
}

type Writer struct {
	out io.Writer
}

func NewWriter(out io.Writer) *Writer {
	return &Writer{
		out: out,
	}
}

// A function to write source
func (w *Writer) writeln(s string) {
	w.out.Write([]byte(s + "\n"))
}

// A function to make the map for transitions
func makeTransitionMap(ts []*Transition) map[*State][]*Transition {
	m := make(map[*State][]*Transition)
	for _, t := range ts {
		if _, ok := m[t.Src]; ok {
			m[t.Src] = append(m[t.Src], t)
		} else {
			m[t.Src] = []*Transition{t}
		}
	}
	return m
}

// A function to generate the string of header
func (g *GoSTMSource) baseHeader(w *Writer) {
	w.writeln("// This file was generated by a program.")
	w.writeln("// Please do not edit this file directly.")
	w.writeln("package " + g.pkg.pkgname + "\n")
	w.writeln("import (\n// package names to be imported\n)\n")
}

// A function to generate Enum for states
func (g *GoSTMSource) baseStateDefinition(w *Writer) {
	stm := g.name
	ss := g.ss
	w.writeln("type " + stm + "State uint8")
	w.writeln("const (")
	for i, s := range ss {
		if i == 0 {
			w.writeln(s.Name + " " + stm + "State = iota")
		} else {
			w.writeln(s.Name)
		}
	}
	w.writeln(")\n")
	w.writeln("var " + stm + "Eod Eod\n")
}

// A function to generate init function
func (g *GoSTMSource) baseStateInitialize(w *Writer) {
	stm := g.name
	i := g.initial
	w.writeln("var " + stm + "CurrentState " + stm + "State\n")
	w.writeln("func init() {")
	w.writeln(stm + "Initialize()")
	w.writeln("}\n")
	w.writeln("func " + stm + "Initialize() {")
	w.writeln(stm + "CurrentState = " + i.Name)
	w.writeln("}\n")
}

//
func (g *GoSTMSource) baseTransDefinition(w *Writer) {
	stm := g.name
	ss := g.ss
	ts := g.ts
	w.writeln("func " + stm + "Task() {")
	w.writeln("switch " + stm + "CurrentState {")
	for _, s := range ss {
		w.writeln("case " + s.Name + ":")
		w.writeln("if " + stm + "Eod == Entry {")
		w.writeln(s.Name + "Entry()")
		w.writeln(stm + "Eod = Do")
		w.writeln("}")
		w.writeln("if " + stm + "Eod == Do {")
		w.writeln(s.Name + "Do()")
		for _, t := range ts[s] {
			w.writeln("if " + t.Event.Name + "Cond() {")
			w.writeln(stm + "CurrentState = " + t.Dest.Name)
			w.writeln(stm + "Eod = Exit")
			w.writeln("}")
		}
		w.writeln("}")
		w.writeln("if " + stm + "Eod == Exit {")
		w.writeln(s.Name + "Exit()")
		w.writeln(stm + "Eod = Entry")
		w.writeln("}")
	}
	w.writeln("}")
	w.writeln("}\n")
}

// A function to generate the string of header for impl
func (g *GoSTMSource) implHeader(w *Writer) {
	w.writeln("// This file was generated by a program.")
	w.writeln("package " + g.pkg.pkgname)
	w.writeln("import (\n// package names to be imported\n)")
}

// A function to generate template functions
func (g *GoSTMSource) implFunctions(w *Writer, sttree map[*State][]*GoSTMSource) {
	ss := g.ss
	ts := g.ts
	for _, s := range ss {
		w.writeln("// functions for State " + s.Name + "\n")
		w.writeln("func " + s.Name + "Entry() {")
		if stms, ok := sttree[s]; ok {
			for _, stm := range stms {
				w.writeln(stm.name + "Initialize() // Call the initialize for " + stm.name)
			}
		}
		w.writeln("if debug {")
		w.writeln("logger.Println(\"Entering State " + s.Name + "\")")
		w.writeln("}")
		w.writeln("// Please write an enter process for State " + s.Name)
		w.writeln("}\n")
		w.writeln("func " + s.Name + "Do() {")
		if stms, ok := sttree[s]; ok {
			for _, stm := range stms {
				w.writeln(stm.name + "Task() // Call the task for " + stm.name)
			}
		}
		w.writeln("// Please write a do process for State " + s.Name)
		w.writeln("}\n")
		w.writeln("func " + s.Name + "Exit() {")
		w.writeln("if debug {")
		w.writeln("logger.Println(\"Leaving State " + s.Name + "\")")
		w.writeln("}")
		w.writeln("// Please write an exit process for State " + s.Name)
		w.writeln("}\n")
		for _, t := range ts[s] {
			w.writeln("func " + t.Event.Name + "Cond() bool {")
			w.writeln("// Please edit the condition")
			w.writeln("return true")
			w.writeln("}\n")
		}
	}
}

// A function to generate common
func (g *GoPkgSource) common(w *Writer) {
	w.writeln("// This file was generated by a program.")
	w.writeln("package " + g.pkgname + "\n")
	w.writeln("import (\n// package names to be imported\n)\n")
	w.writeln("type Eod uint8\n")
	w.writeln("const (")
	w.writeln("Entry Eod = iota")
	w.writeln("Do")
	w.writeln("Exit")
	w.writeln(")\n")
	w.writeln("type DebugLogger interface {\nPrintln(string)\n}\n")
	w.writeln("var logger DebugLogger\n")
	w.writeln("func ConfigureLog(p DebugLogger) {\nlogger = p\n}\n")
	w.writeln("const (\ndebug = true\n)\n")
}

// A function to generate an example of test code
func (g *GoPkgSource) testGen(w *Writer, stmname string) {
	w.writeln("// This file was generated by a program.")
	w.writeln("package " + g.pkgname + "\n")
	w.writeln("import (\n\"log\"\n\"testing\"\n\"time\"\n stm2go \"github.com/JuliaMBD/stm2go/testing\"\n)\n")
	w.writeln("type DebugStruct struct{}\n")
	w.writeln("func (l DebugStruct) Println(s string) {")
	w.writeln("log.Println(s)")
	w.writeln("}\n")
	w.writeln("var logTest = DebugStruct{}\n")
	w.writeln("func " + g.pkgname + "TestExample(t *testing.T) {")
	w.writeln("env := stm2go.NewTestEnv()\n")
	w.writeln("env.Add(stm2go.Continue, func() {")
	w.writeln("for {")
	w.writeln("time.Sleep(10 * time.Millisecond)")
	w.writeln(stmname + "Task()")
	w.writeln("}")
	w.writeln("})")
	w.writeln("env.Add(stm2go.Done, func() {")
	w.writeln("})")
	w.writeln("env.Set(1)")
	w.writeln("env.Go()")
	w.writeln("}")
}

// A function to generate an example of main
func (g *GoPkgSource) testMain(w *Writer, stmname string) {
	w.writeln("package main\n")
	w.writeln("import (\"time\"\n" + g.pkgname + " \"" + g.fullpkgname + "/" + srcdir + "\"\n)\n")
	w.writeln("func main() {")
	w.writeln("for {")
	w.writeln(g.pkgname + "." + stmname + "Task()")
	w.writeln("time.Sleep(time.Millisecond * 10)")
	w.writeln("}")
	w.writeln("}")
}
